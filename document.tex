%!TEX options = --shell-escape
\input{imports/def}

\colorlet{documentColor}{darkred}

\begin{document}

\tableofcontents
\chapter{SQL-Injections im Jahr 2016}

\mymarginnote[-2em]{Derzeit werden Daten für die kommende OWASP Top Ten 2016 gesammelt.}
\lettrine[lines=2]{A}{}lle drei Jahre veröffentlicht das \emph{Open Web Application Security Project} -- kurz OWASP -- eine Liste der derzeit als am kritischsten eingestuften Sicherheitsrisiken in Webapplikationen. Und auch in der derzeit aktuellsten Fassung der Liste aus dem Jahr 2013 findet sich die Kategorie \enquote{Injections} auf Platz Eins wieder.

\begin{table}[ht!]
\begin{margincap}
\caption{Die ersten drei Kategorien der aktuellen OWASP Top Ten aus dem Jahr 2013, nach \texttt{www.owasp.org}}
\label{tab:owasp_top_ten}
\centering
\begin{tabu} to \textwidth {l l X<{\strut} l}
	\rowfont{\sffamily\bfseries\leavevmode\color{white}}
	\rowcolor{tableHeader}
	& & Kategorie & \\
	\rowfont{\sffamily}
	& 1 & Injection & \\
	\rowfont{\sffamily}
	& 2 & Broken Authentication & \\
	\rowfont{\sffamily}
	& 3 & Cross-Site-Scripting & \\
\end{tabu}
\end{margincap}
\end{table}

Derartige Angriffe basieren darauf, dass Benutzereingaben ungeprüft in Abfragen an LDAP"=Dienste und vor allem SQL"=Datenbanken als Parameter eingefügt werden. Entsprechend geformte Eingaben können somit die grundlegende Struktur der Anfrage manipulieren. Diese Manipulation kann Verlust der Informationsvertraulichkeit oder der Datenintegrität zur Folge haben, unter Umständen kann ein Angreifer Vollzugriff auf die zugrundeliegende Serverstruktur erhalten. Die vorliegende Arbeit konzentriert sich hierbei insbesondere auf gefährdete SQL"=Anfragen.

\section{Verhinderung von SQL"=Injections}

\mymarginnote[-2em]{\enquote{Don't trust user input.}}
Es stellt sich folglich die Frage, wie derartige Angriffe verhindert werden können. Die übliche Vorgehensweise stellt hierbei die Überprüfung der vom Client übergebenen Parameter dar. Etwa könnte unter PHP ein Parameter, für den nur Ganzzahlen vorgesehen sind, per Konvertierung durch \mintinline{php}{intval()} abgesichert werden. \mymarginnote[-3em]{Diese PHP"=Funktion ersetzt beispielsweise ' durch \textbackslash'.  Dadurch wird es erschwert, das aktuelle String"=Literal im SQL"=Statement zu beenden und zusätzliche Befehle anzufügen.} Bei beliebigen Zeichenketten escaped die Funktion \mintinline{php}{mysql_real_escape_string()} bestimmte Zeichen, die einen Ausbruch aus der Abfrage erlauben können. Sicherer sind allerdings sogenannte \emph{Prepared Statements}, die die Anfrage und die zugehörigen Parameter getrennt voneinander übertragen und dadurch Injections verhindern.

Wenn also die Verhinderung von SQL"=Injections eine triviale Angelegenheit ist, weshalb bestimmen auch heutzutage Nachrichten über aktuelle, derartige Angriffe die Fachpresse? Die Gründe hierfür sind vielfältig. Möglicherweise ist veraltete Software im Einsatz oder dem Entwickler mangelt es schlicht an Vorwissen im Bereich der IT"=Sicherheit.
\mymarginnote[-3em]{Ein weiteres Beispiel könnte zugekaufte Fremdsoftware darstellen, die im eigenen Netzwerk betrieben wird.}
Ebenfalls vorstellbar ist Software, die nicht mehr geändert werden kann -- etwa weil der Aufwand zu groß wäre, keine Entwickler vorhanden sind, oder aber der zugehörige Sourcecode nicht zur Verfügung steht.

Außerdem können Queries konstruiert werden, die ein fachliches Problem zwar auf einfache Weise lösen, andererseits jedoch die Verwendung eines parametrisierten Prepared Statements unmöglich machen.

\begin{listing}
\begin{margincap}
\inputminted[startinline,obeytabs]{php}{imports/weak_features.php}
\caption{In diesem PHP"=Code wird mit der Variable \mintinline{php}{choosenText} eine Spalte und mit \mintinline{php}{sorting} eine Sortierreihenfolge ausgewählt. In beiden Fällen können keine Parameter für Prepared Statements verwendet werden.}
\label{lst:strange_query}
\end{margincap}
\end{listing}

\section{Alternativen}
In all diesen Fällen muss die gefährdete Applikation also auf andere Art und Weise abgesichert werden. Ein gängiger Ansatz zur Realisierung einer solchen Schutzmaßnahme stellt eine vorgeschaltete Softwarekomponente dar, welche auf Basis von Filterregeln einzelne Requests verwirft oder modifiziert. Hierzu soll zuerst ein übliches Schema einer Client"=Server"=Architektur skizziert werden.

\begin{figure}
\begin{margincap}
\centering
\begin{tikzpicture}[every node/.style={ultra thick,draw=black!60, font=\large\sffamily\color{black!60},inner sep=8pt,text height=1.5ex,text depth=.25ex,node distance=1.2cm,}]
\node(hacker) {Client};
\node[right = of hacker.east, minimum width = 3pt,fill=darkred, minimum height=3cm](firewall)  {};
\node[below =0.1cm of firewall.south,draw=none] {Firewall};


\node[right = of firewall.east](server)  {Webserver};
\node[right = of server.east](app)  {Anwendung};
\node[below = of app.south](db)  {Datenbank};


\draw[ultra thick,draw=black!60,] (hacker) -- (firewall) -- (server) -- (app) -- (db);
\end{tikzpicture}

\caption{Zugriffe auf eine Webserverapplikation passieren üblicherweise zuerst eine Firewall und werden anschließend von einem Webserver -- etwa \emph{Apache} -- zur Applikation weitergeleitet. Diese Applikation kann anschließend auf den Datenbankserver zugreifen.}
\label{img:server_arch}
\end{margincap}
\end{figure}

%TODO Logging --> passives Verhalten, um noch nicht entdeckte Schwachstellen aufzudecken

\mymarginnote[-2em]{Ein Beispiel hierfür stellen etwa \emph{Load Balancer} zur Lastverteilung auf mehrere Server dar.}
In aktuellen Webserverarchitekturen können weitere Komponenten enthalten sein, die an dieser Stelle jedoch vernachlässigt und abstrahiert werden sollen.

In dem abstrakten Schema eines Requests aus Abbildung \ref{img:server_arch} bieten sich zwei Stellen an, an welchen einzelne Parameter der Anfrage auf ihre Gefährlichkeit in Bezug auf SQL"=Injections hin untersucht werden können. Analysiert man die beispielsweise die GET und POST Parameter eines Requests noch bevor sie beim Webserver ankommt, spricht man von einer \emph{Web Application Firewall}. Alternativ können auch die Zugriffe auf den Datenbankserver selbst untersucht werden -- und zwar von einer vorgeschalteten \emph{Datenbank"=Firewall.}\mymarginnote[-4em]{Sowohl Web Application Firewall als auch Datenbank"=Firewall stellen \emph{Intrusion Detection} Systeme dar.} Es stellt sich die Frage, inwiefern die beiden Ansätze in Bezug auf ihre Effektivität miteinander vergleichbar sind -- und ob sie einen wirksamen Schutz vor SQL"=Injections bieten können.


\begin{figure}
\begin{margincap}
\centering
\begin{tikzpicture}[every node/.style={ultra thick,draw=black!60, font=\large\sffamily\color{black!60},inner sep=8pt,text height=1.5ex,text depth=.25ex,node distance=0.5cm,}]
\node(hacker) {Hacker};
\node[right = of hacker.east, minimum width = 3pt,fill=darkred, minimum height=3cm](firewall)  {};
\node[below =0.1cm of firewall.south,draw=none] {Firewall};


\node[right = of firewall.east](server)  {Webserver};
\node[right = of server.east,fill = documentColor,font=\large\sffamily\color{white}](waf)  {WAF};
\node[right = of waf.east](app)  {Anwendung};
\node[below = of app.south,fill = documentColor,font=\large\sffamily\color{white}](dbf)  {DB-Firewall};
\node[below = of dbf.south](db)  {Datenbank};


\draw[ultra thick,draw=black!60,] (hacker) -- (firewall) -- (server) -- (waf) -- (app) -- (dbf) -- (db);
\end{tikzpicture}
\caption{In die Abbildung \ref{img:server_arch} wurden an den entsprechenden Stellen Schutzmechanismen eingefügt. Möglichkeiten hierfür sind eine \emph{Web-Application Firewall} -- kurz WAF -- und eine \emph{Datenbank-Firewall}. Es stellt sich die Frage, wie effektiv die jeweiligen Maßnahmen SQL"=Injections mitigieren können.}
\label{img:protected_server_arch}
\end{margincap}
\end{figure}

\chapter{Arten von SQL-Injections}
\lettrine[lines=2]{S}{}QL"=Injections lassen sich nach unterschiedlichen Kriterien klassifizieren. Dies geschieht in Hinblick auf die Art und Weise wie ein Angreifer die verwundbare SQL"=Anfrage entdeckt, wie er den Schadcode einfügt und schließlich Daten auslesen kann. In diesem Kapitel soll ein grober Überblick über verschiedene Ansätze von SQL"=Injections vermittelt werden.

\section{Tautologie"=basierte Injection}

Die einfachste Variante einer SQL"=Injection sorgt dafür, dass eine logische Überprüfung im \mintinline{sql}{WHERE}"=Teil der Abfrage immer zu \texttt{true} evaluiert und somit alle betroffenen Zeilen zurückgegeben werden. Das Paradebeispiel hierfür ist eine Abfrage zur Authentisierung eines Benutzers.


\begin{listing}
\begin{margincap}
\inputminted[startinline,obeytabs]{php}{imports/login_1.php}
\caption{Eine einfache Anmeldungslogik: Wird in der Datenbank ein Nutzer mit dem übergebenen Nutzernamen und Passwort gefunden, wird eine Sessionvariable gesetzt. }
\label{lst:login_query}
\end{margincap}
\end{listing}

Wenn ein Angreifer die Logindaten jeweils auf \mintinline{sql}{' OR '' = '} setzt, wird jeweils überprüft, ob ein Leerstring identisch zu einem Leerstring ist. Da dieser Vergleich immer \texttt{true} ergibt, werden alle in der Tabelle \texttt{users} enthaltenen Zeilen zurückgegeben. Der Benutzer wird eingeloggt.

\section{UNION based Injection}

Etwas komplexer als die im vorherigen Abschnitt vorgestellte Methode sind Anfragen, welche die Menge der zurückgegebenen Zeilen eines \mintinline{sql}{SELECT} Statements durch ein angefügtes \mintinline{sql}{UNION} erweitern. Wichtig ist hierbei, dass die Anzahl der Spalten der mit \mintinline{sql}{UNION} angefügten Query identisch mit der Spaltenanzahl der ursprünglichen  \mintinline{sql}{SELECT} Abfrage sein muss. Führt der restliche Teil der originalen Abfrage zu Problemen, kann er gegebenenfalls auskommentiert werden. Hierzu muss an das Ende des injizierten \mintinline{sql}{UNION} Teils per \mintinline{sql}{--} ein Kommentar eingeleitet werden.


\section{Statement Injection}

\emph{Statement Injection } funktioniert ähnlich wie die \mintinline{sql}{UNION} basierte Variante, jedoch wird hier eine komplette, zusätzliche SQL"=Abfrage eingefügt. Hierzu wird zuerst die aktuelle Anfrage valide vervollständigt und anschließend per Semikolon beendet. Nun kann ein eigenständiges SQL"=Statement angehängt werden -- beispielsweise \mintinline{sql}{DROP DATABASE wordpress;}. Folgender SQL"=Code kann wie im vorherigen Abschnitt erläutert einfach auskommentiert werden.
\mymarginnote[-4em]{ {\color{documentColor}\bfseries Angemerkt: }In einem \texttt{xkcd} Webcomic unter \url{https://xkcd.com/327/} löscht eine Mutter Daten der Schule: Sie hatte ihren Sohn \enquote{\texttt{Robert'); DROP TABLE Students; --}} getauft -- Ein klassisches Beispiel für eine Statement Injection.}


Damit derartige Angriffe unter PHP funktionieren, muss statt der Funktion \mintinline{php}{mysqli_query()} die Variante \mintinline{php}{mysqli_multi_query()} verwendet werden. Andernfalls ist die Verwendung konkatenierter SQL"=Statements nicht möglich.


\section{Error based SQL Injection}

Wenn eine Anfrage zwar anfällig für SQL"=Injections ist, die zugehörige Webseite allerdings keine Daten direkt ausgibt, können möglicherweise dennoch Daten ausgelesen werden. In manchen Webanwendungen wird bei einem Fehler in einer Datenbankabfrage die entsprechende Fehlermeldung ausgegeben. Kann diese Ausgabe durch die Injection provoziert und geändert werden, so ist eine \emph{Error based SQL Injection} möglich.


\begin{listing}
\begin{margincap}
\inputminted[startinline,obeytabs]{php}{imports/cp_multi_error.php}
\caption[cp multi view calendar]{Ein Auszug aus dem Wordpress"=Plugin \texttt{cp multi view calendar}\footnote{\url{https://github.com/wp-plugins/cp-multi-view-calendar}}. Die Variable \texttt{id} wird nicht überprüft und ermöglicht so SQL"=Injections. Im Fehlerfall wird die Meldung in Zeile 7 in eine lokale Variable geschrieben und später ausgegeben.}
\label{lst:cp_multi_error}
\end{margincap}
\end{listing}

Übergibt man als \texttt{id} etwa \mintinline{sql}{EXTRACTVALUE(0x0a,(SELECT USERNAME())}, so wird der Inhalt von Listing \ref{lst:error_based_output} ausgegeben. Die Funktion \mintinline{sql}{EXTRACTVALUE} erwartet als zweiten Parameter eine gültige XPath"=Anweisung. Der Benutzername, der per \mintinline{sql}{USERNAME()} in einer Subquery ausgelesen wird, ist kein gültiges Argument -- und wird daher in der Fehlermeldung mit ausgegeben.

\begin{listing}
\begin{margincap}
\begin{minted}[obeytabs]{json}
{
    "IsSuccess":false,
    "Msg":"XPATH syntax error: '@localhost'"
}
\end{minted}
\caption{Ausgabe der \emph{Error based} SQL"=Injection. In der Fehlermeldung ist das Resultat der Subquery zu sehen, in diesem Fall der Rückgabewert der Funktion \mintinline{sql}{USERNAME().}}
\label{lst:error_based_output}
\end{margincap}
\end{listing}


\section{Time based SQL injection}

Ändert sich an der Ausgabe der Seite trotz erfolgreich ausgeführter SQL"=Injection nichts, so ist es dennoch möglich, Daten auszulesen. Hierfür werden SQL Funktionen wie \mintinline{sql}{SLEEP()} oder \mintinline{sql}{BENCHMARK()} verwendet, die die Ausführungsdauer einer Query erhöhen können. Verbindet man dies mit einer \mintinline{sql}{IF()} Bedingung und misst die Dauer des gesamten Requests, so erlaubt dies erneut Rückschlüsse auf Datenbankinhalte.

\begin{listing}
\begin{margincap}
\begin{minted}[obeytabs]{sql}
(
    SELECT
        IF(
            SUBSTRING(user.Password,1,1) = CHAR(12)
            ,SLEEP(5)
            ,2
        )
    FROM
        mysql.user
    LIMIT
        1
)
\end{minted}
\caption[timebased]{Diese Query vergleicht ein einzelnes Zeichen einer Zeichenkette mit einem bestimmten ASCII"=Code. Liefert der Vergleich \texttt{true}, so wird fünf Sekunden gewartet.}
\label{lst:time_based}
\end{margincap}
\end{listing}

\chapter{Versuchsbeschreibung}

Folgende Abschnitte sollen aufzeigen, wie im Zuge dieser Seminararbeit die Tauglichkeit verschiedener automatisierter Angriffs- und Verteidigungsmechanismen rund um SQL-Injections getestet wurde.

\section{Grundlegende Überlegungen}

Wenn die Bewertung einer derartigen Abwehrmaßnahme zum Thema wird, kommen zwei einfache Metriken in Frage: die Anzahl der \emph{false positives} und die der \emph{true negatives}. Wie viele HTTP"=Anfragen führen zwar zu SQL"=Injections, werden jedoch nicht erkannt -- und auf der anderen Seite: Wie viele Anfragen werden verworfen, obwohl sie eigentlich ungefährlich sind?

Je eines der Beiden zu 100\% zu erfüllen ist einfach: \emph{false positives} werden verhindert, indem die Firewall alle Anfragen blockiert, \emph{true negatives} treten nicht auf, wenn keine einzige Überprüfung stattfindet oder die Abwehrmaßnahme komplett deaktiviert wird. Da beide Extreme üblicherweise unerwünscht sind, gilt es ein passendes Mittelmaß zu finden.

\mymarginnote{Um ein Beispiel zu geben: Einem harmlosen Benutzer, der sich \texttt{"DROP DATABASE"} nennen möchte, eine Fehlermeldung zu präsentieren, ist der Wirtschaftlichkeit der Website meist weniger abträglich als das Löschen der kompletten Datenbank.}Es sei zudem darauf hingewiesen, dass die Nichterkennung einer SQL"=Injection größeren Schaden verursachen kann als das versehentliche Verwerfen einer normalen Anfrage.

\section{Verwendete Werkzeuge}

Bezugnehmend auf die Abbildung \ref{img:protected_server_arch} wird jeweils eine Web Application Firewall und eine Database Firewall getestet. Damit diese Tests möglich sind, muss zum einen die grundlegende Infrastruktur aufgebaut werden: Die Basis bildet ein Apache 2.4 Webserver auf einem Linux"=Serversystem.\mymarginnote{Zum Einsatz kommt ein 64"=bit Ubuntu Server. Siehe auch {\url{http://www.ubuntu.com/download/server}}} Damit Angriffe möglich sind, muss eine für SQL"=Injections verwundbare Applikation eingerichtet werden. Mögliche Schwachstellen werden schließlich automatisiert mit dem Tool \emph{sqlmap} gesucht und getestet.

\section{Versuchsablauf}

Schwachstellen, die mit sqlmap entdeckt wurden, werden als \texttt{Request} Objekte in einem Pythonskript zusammengefasst. Anschließend wird je eine der beiden Abwehrmaßnahmen aktiviert. Das Pythonskript führt die Requests der Reihe nach aus und überprüft ob die SQL"=Injection erfolgreich abgefangen wurde. Abschließend wird eine Statistik der erfolgreichen und der abgewehrten SQL"=Injections ausgegeben.


\section{Automatisierung der SQL-Injections mit sqlmap}

Zum Auffinden verwundbarer Request"=Parameter wurde das Python basierte Werkzeug \emph{sqlmap} ausgewählt. Es bietet verschiedene Kommandozeilenoptionen an, deren Verwendung an dieser Stelle kurz erläutert wird.\mymarginnote{Vergleiche hierzu \url{https://github.com/sqlmapproject/sqlmap/wiki/Usage}} Das frei verfügbare Tool kann von \url{http://sqlmap.org/} aus installiert werden.

\begin{listing}
\begin{minted}{bash}
> python sqlmap.py -u "http://www.example.com/app.php?id=1"
\end{minted}
\end{listing}

Mit dem Parameter \texttt{-u} wird die anzugreifende URL angegeben. Bereits dieses Argument genügt für eine erste Analyse: Standardmäßig wird ein \texttt{GET}"=Request verwendet und dabei versucht, alle in der URL enthaltenen Parameter anzugreifen. Hierbei setzt sqlmap verschiedene mögliche Payloads für die angegeben Parameter ein und überprüft anhand der Serverantwort, ob die SQL"=Injection erfolgreich war.

\begin{listing}
\begin{minted}[breaklines]{bash}
> python sqlmap.py -u "http://www.example.com/app.php" --data={username=&password=}
\end{minted}
\end{listing}

sqlmap ist ebenfalls in der Lage, \texttt{POST}"=Requests durchzuführen. Hierzu werden die Parameter mit dem Argument \texttt{--data} angegeben.


\begin{listing}
\begin{minted}[breaklines]{text}
sqlmap identified the following injection point(s) with a total of 307 HTTP(s) requests:
---
Parameter: username (POST)
    Type: boolean-based blind
    Title: OR boolean-based blind - WHERE or HAVING clause (MySQL comment) (NOT)
    Payload: uname=") OR NOT 7407=7407#&passwd=

    Type: AND/OR time-based blind
    Title: MySQL >= 5.0.12 OR time-based blind (comment)
    Payload: uname=") OR SLEEP(5)#&passwd=
\end{minted}
\end{listing}

Findet sqlmap verwundbare Parameter, so werden diese zusammen mit dem genutzten Payload ausgegeben. Im obigen Beispiel war der Parameter \texttt{username} angreifbar, sqlmap liefert hierzu eine time-based und eine boolean-based SQL"=Injection.

\begin{listing}
\begin{minted}[breaklines]{bash}
> python sqlmap.py --level=5 -u "http://www.example.com/app.php" --data={username=&password=}
\end{minted}
\end{listing}

Gelingt es sqlmap nicht, eine SQL"=Injection zu finden, so kann mit \texttt{--level} die Anzahl der getesteten SQL"=Injection"=Varianten erhöhen -- wobei 1 die niedrigste Stufe und 5 jene Stufe mit der größten Zahl an Anfragen darstellt. Neben der Anzahl der möglichen Varianten pro Parameter werden mit höheren Stufen auch Cookies und HTTP"=Header getestet. Die größere Anzahl an Anfragen hat allerdings auch eine längere Ausführungsdauer des Befehls zur Folge.

\begin{listing}
\begin{minted}[breaklines]{bash}
> python sqlmap.py  -o --dbms=MySQL -u "http://www.example.com/app.php?id"
\end{minted}
\end{listing}

Gerade hierfür kann die Verwendung der Argumente \texttt{-o} und \texttt{--dbms} sinnvoll sein. Mit \texttt{-o} werden allgemeine optimierende Optionen aktiviert -- etwa Multithreading -- welche die Ausführungsdauer reduzieren können. Ist das verwendete Datenbankmanagementsystem bekannt, so kann auch mit der Angabe von \texttt{--dbms} verhindert werden, dass SQL"=Injections, die für andere DBMS spezifischen Code enthalten, durchgeführt wird.


\section{Verwundbare Beispielapplikation}

\section{Apache und ModSecurity}

\section{MySQL Enterprise: Datenbank und Firewall}


\chapter{Ergebnisse}

90 von 90,

keine 100% bei ModSecurity "1' or' "


\end{document}